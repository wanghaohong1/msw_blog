# 典型故障案例

记录线上高频异常场景，覆盖告警信号、定位手段与长期改进措施。

## 案例一：缓存雪崩导致接口超时
- **背景**：Redis 大量热点 Key 同时过期，后端瞬时打到数据库，QPS 猛增。
- **现象**：请求延迟 >5s，Redis 命中率骤降，数据库 CPU 飙升。
- **定位过程**：
  1. Prometheus 指标显示缓存命中率下降、DB QPS 上升。
  2. Redis `info stats` 显示大量 `miss`，数据库慢查询堆积。
  3. 分析后确认批量设置了相同过期时间。
- **处理动作**：临时扩容数据库连接池，手动热点数据预热，引入互斥锁刷新。
- **改进措施**：为热点缓存增加随机过期、引入本地缓存兜底、实现缓存刷新任务。

## 案例二：数据库死锁导致订单创建失败
- **背景**：两条订单流程同时更新库存与优惠券，SQL 执行顺序不同引发死锁。
- **现象**：接口返回 500，日志出现 `Deadlock found when trying to get lock`。
- **定位过程**：
  1. 通过 APM 捕获异常堆栈，定位到库存更新 SQL。
  2. 执行 `show engine innodb status\G` 查看死锁信息，确认两事务互相等待。
  3. 排查代码发现事务中 SQL 顺序不一致。
- **处理动作**：将涉及库存与优惠券操作的 SQL 顺序统一；短期增加重试机制。
- **改进措施**：引入库存服务化接口，关键资源使用分布式锁，规范事务访问顺序。

## 案例三：消息队列堆积导致数据延迟
- **背景**：促销活动引发订单量暴增，消费端处理能力不足。
- **现象**：Kafka lag 急剧上升，延迟超过 10 分钟，业务报警。
- **定位过程**：
  1. 监控显示消费速率明显低于生产速率。
  2. 查看消费者日志，有大量数据库写入慢导致消费阻塞。
  3. 数据库查询慢日志显示新增索引缺失。
- **处理动作**：临时扩容消费者实例，分摊压力；对数据库新增索引、优化写入逻辑。
- **改进措施**：扩展异步处理能力，增加按流量自动伸缩策略，提前压测访问路径。

## 案例四：JVM 内存泄漏导致频繁 Full GC
- **背景**：新上线功能使用 ThreadLocal 缓存大对象但未清理。
- **现象**：应用内存持续增长，GC 日志显示 Full GC 间隔缩短。
- **定位过程**：
  1. 通过 Prometheus 监控发现 Old 区占用接近 90%。
  2. 使用 `arthas heapdump`，借助 MAT 分析 Dominator Tree，定位到 ThreadLocalMap。
  3. 代码审查发现 ThreadLocal 未在 finally 中清理。
- **处理动作**：热修复更新 ThreadLocal 使用方式并重启实例。
- **改进措施**：引入内存监测告警、代码评审检查 ThreadLocal 使用规范、增加自动化内存回归测试。

